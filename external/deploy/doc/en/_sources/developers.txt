.. _developers:

************************
Разработчикам приложений
************************

Простейшее приложение (Hello world!)
====================================

Простейшее приложение на движке может иметь вид:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_version = b4w.require("version");
        document.body.innerHTML = "Hello, Blend4Web " + m_version.version() + "!";
    }
    </script>
    </head>

    <body onload="hello()"></body>

    </html>

Базовый модуль движка подключается с помощью тега ``<script src="...">``. Далее,
приложение ожидает окончания загрузки страницы и выводит сообщение с текущей
версией в окне браузера.


Загрузка сцены в приложение
===========================

Для того, чтобы загрузить трёхмерную сцену, требуется выполнить следующую
последовательность действий:

#. Разместить на странице элемент ``<canvas>``, на котором будет производиться
   рендеринг.

#. После загрузки страницы, для инициализации контекста WebGL, вызвать функцию
   ``m_main.init()`` с идентификатором созданного элемента.

#. Вызвать функцию ``m_data.load()`` для загрузки трёхмерной сцены.

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_main = b4w.require("main");
        var m_data = b4w.require("data");

        var canvas_elem = document.getElementById("canvas_id");
        m_main.init(canvas_elem);
        m_data.load("some_scene.json");
    }
    </script>
    </head>

    <body onload="hello()"><canvas id="canvas_id"></canvas></body>

    </html>

Следует отметить, что реальное приложение должно включать в себя проверку
ошибок, настройку движка перед инициализацией, а также базовую систему
взаимодействия с пользователем.


Быстрое создание приложений 
===========================

Поскольку создание приложения с нуля может быть достаточно сложной операцей,
особенно для начинающих пользователей, в движке существует специальное
дополнение ``app.js``. Дополнение подключается аналогично основному модулю
``b4w.min.js`` и доступно в приложении через модуль ``app``:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script src="app.js"></script>
    <script>

    var m_app = b4w.require("app");
    var m_data = b4w.require("data");

    m_app.init({
        canvas_container_id: "body_id",
        callback: load_cb
    });

    function load_cb() {
        m_data.load("some_scene.json");
    }

    </script>
    </head>

    <body id="body_id"></body>

    </html>

В данном случае модуль ``app`` создаст элемент ``<canvas>`` внутри контейнера с
указанным идентификатором ``body_id``, осуществит инициализацию движка при
загрузке страницы и сообщит о её окончинии с помощью обработчика ``load_cb``.


Система модулей
===============

Несмотря на то, что движок предоставляет прикладному программисту API в объёме
десятков модулей, в процессе работы он занимает в глобальном пространстве имён
единственный объект ``b4w``. При необходимости обращения к модулю, последний
импортируется с помощью вызова функции ``b4w.require``. 

Допустима регистрация сторонних модулей, если их имена не пересекаются с
имеющимися. Регистрация происходит посредством вызова ``b4w.register``.
Проверка наличия модуля с некоторым именем может быть осуществлена с помощью
``b4w.module_check``.

Пример:

.. code-block:: javascript

    // check if module exists
    if (b4w.module_check("my_module"))
        throw "Failed to register module: my_module";

    // register my_module
    b4w.register("my_module", function(exports, require) {

        // import module "version"
        var m_version = require("version");

        // export print_build_date() from module "my_module"
        exports.print_build_date = function() {
            // exec function date() from module "version"
            console.log("Engine build date: " + m_version.date());
        }
    });

    // import module "my_module"
    var m_my_module = b4w.require("my_module");

    // exec function print_build_date() from module "my_module"
    m_my_module.print_build_date();




Управление перемещением объектов
================================

.. note::

    Необходимо обеспечить, чтобы объект, над которым выполняется преобразование, был динамическим (т.е. физическим или анимированным), либо одиночным (этого можно добиться, установив свойство ``Blend4Web > Do not batch`` на вкладке ``Object`` в программе Blender).

Для управления перемещением объектов в движке предусмотрены следующие базовые функции модуля `transform`:

*get_translation*
    Получить координаты центра объекта. Вариант с одним параметром возвращает
    новый вектор (неоптимизированный вариант), вариант с двумя требует
    отдельного вектора для записи результата.

*get_rotation*
    Получить кватернион поворота объекта. По аналогии с `get_translation` имеется два варианта вызова функции.
    
*get_scale*
    Получить значение коэффициента увеличения объекта.

*set_translation, set_translation_v*
    Переместить центр объекта в указанное место. Первая функция принимает в качестве параметров отдельные координаты, вторая - трёхмерный вектор (Array или Float32Array).
    
*set_rotation, set_rotation_v*
    Установить кватернион поворота объекта. Первая функция принимает в качестве параметров отдельные координаты, вторая - четырёхмерный вектор (Array или Float32Array).

*set_scale*
    Установить коэффициент увеличения объекта. Единица соответствует исходному состоянию. Значение меньше единицы - уменьшение. Значение больше единицы - увеличение. Не все объекты могут быть увеличены. В частности, увеличение невозможно для физических объектов.

*set_rotation_euler, set_rotation_euler_v*
    Установить поворота объекта с помощью углов Эйлера. Используется
    **внутренняя** (intrinsic) система поворота YZX (то есть углы следуют в
    последовательности YZX, сама система отсчёта при этом вращается и занимает
    каждый раз новое положение).



.. index:: кватернион

Кватернионы
===========

Кватернионы представляют собой четырёхмерные векторы, используемые для осуществления поворотов. Использование кватернионов обладает рядом преимуществ перед другими способами представления поворотов:

    - Не имеет неоднозначности и зависимости от порядка применения поворотов, которые имеют место в случае использования углов Эйлера.
    - Более эффективное использование памяти (от 2-х до 4-х раз меньше в зависимости от типа используемой матрицы).
    - Высокая эффективность вычисления серии поворотов, чем при использовании матриц.
    - Нейтрализация ошибок умножения, возникающих вследствие неточности чисел с плавающей запятой.
    - Удобный метод интерполяции.
    
Кватернионы имеют ряд недостатков:
    - Поворот вектора с помощью кватерниона более сложная в вычислительном плане операция чем поворот с использованием матрицы.
    - Использование кватернионов для представления отличных от поворота преобразований (перспективная или ортогональная проекция) затруднено.

Для удобства работы с кватернионами в движке имеется ряд функций:

*quat.multiply*
    Умножение кватернионов. Умножение кватерниона А на кватернион Б слева A*Б является поворотом на A. То есть у объекта уже имеется некий поворот Б, который мы дополняем новым поворотом на A.
    
*quat.setAxisAngle*
    Кватернион представляет собой иную форму записи поворота относительно произвольной оси (вектора) на произвольный угол. Положительное направление поворота отсчитывается против часовой стрелки, если смотреть с конца вектора. Например вызов :code:`quat.setAxisAngle([1,0,0], Math.PI/3, quat)` сформирует кватернион, который может быть использован для осуществления поворота относительно оси X на 60 градусов (против часовой стрелки, если смотреть с конца оси X).
    
*quat.slerp*
    Сферическая интерполяция кватернионов. Используется для осуществления плавного разворота объектов и анимации.

*util.euler_to_quat, util.quat_to_euler*.
    Преобразование из углов Эйлера и наоборот.
    

Пример работы с кватернионами
-----------------------------

Требуется повернуть объект на 60 градусов в горизонтальной плоскости вправо. В программе Blender имеется соответствующая модель с названием "Cessna". 

.. image:: src_images/developers/aircraft.jpg
   :alt: ориентация модели в программе Blender
   :align: center
   :width: 100%

|

Сохраним ссылку на объект в движке в переменной **aircraft**:
    
.. code-block:: javascript

    var aircraft = b4w.scenes.get_object_by_name("Cessna");


Осуществим поворот:

    * Расположение координатных осей в Blender'е и в движке различается, и при экспорте произойдет преобразование: [X Y Z] (Blender) -> [X -Z Y] (движок). Поэтому поворот нужно осуществлять относительно оси Y, а не Z. 
    * Повороту вправо соответствует поворот по часовой стрелке, т.е. в отрицательном направлении. 
    * 60 градусов = :math:`\pi/3` радиан. 
    
В итоге получаем:
    
.. code-block:: javascript
    
    // compose quaternion
    var quat_60_Y_neg = b4w.quat.setAxisAngle([0, 1, 0], -Math.PI/3, b4w.quat.create());

    // get old rotation
    var quat_old = b4w.transform.get_rotation(aircraft);

    // left multiply: quat60_Y_neg * quat_old
    var quat_new = b4w.quat.multiply(quat_60_Y_neg, quat_old, b4w.quat.create());

    // set new rotation
    b4w.transform.set_rotation_v(aircraft, quat_new);


Оптимизированный вариант, не приводящий к созданию новых объектов:

.. code-block:: javascript
    
    // cache arrays as global vars
    var AXIS_Y = new Float32Array([0, 1, 0])
    var quat_tmp = new Float32Array(4);
    var quat_tmp2 = new Float32Array(4);
    ...
    // rotate
    b4w.quat.setAxisAngle(AXIS_Y, -Math.PI/3, quat_tmp);
    b4w.transform.get_rotation(aircraft, quat_tmp2);
    b4w.quat.multiply(quat_tmp, quat_tmp2, quat_tmp);
    b4w.transform.set_rotation_v(aircraft, quat_tmp);
    


