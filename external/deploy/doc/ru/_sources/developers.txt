.. _developers:

*************
Разработчикам
*************

Подключение движка и дополнений
===============================

Простейшее приложение на движке может иметь вид:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_version = b4w.require("version");
        document.body.innerHTML = "Hello, Blend4Web " + m_version.version() + "!";
    }
    </script>
    </head>

    <body onload="hello()"></body>

    </html>

Базовый модуль движка подключается с помощью тега ``<script src="...">``. Далее,
приложение ожидает окончания загрузки страницы и выводит сообщение с текущей
версией в окне браузера.

Для того, чтобы загрузить трёхмерную сцену, требуется выполнить следующую
последовательность действий:

#. Разместить на странице элемент ``<canvas>``, на котором будет производиться
   рендеринг.

#. После загрузки страницы, для инициализации контекста WebGL, вызвать функцию
   ``m_main.init()`` с идентификатором созданного элемента.

#. Вызвать функцию ``m_data.load()`` для загрузки трёхмерной сцены.

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_main = b4w.require("main");
        var m_data = b4w.require("data");

        var canvas_elem = document.getElementById("canvas_id");
        m_main.init(canvas_elem);
        m_data.load("some_scene.json");
    }
    </script>
    </head>

    <body onload="hello()"><canvas id="canvas_id"></canvas></body>

    </html>

Следует отметить, что реальное приложение должно включать в себя проверку
ошибок, настройку движка перед инициализацией, а также базовую систему
взаимодействия с пользователем.

Поскольку создание приложения с нуля может быть достаточно сложной операцей,
особенно для начинающих пользователей, в движке существует специальное
дополнение ``app.js``. Дополнение подключается аналогично основному модулю
``b4w.min.js`` и доступно в приложении через модуль ``app``:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script src="app.js"></script>
    <script>

    var m_app = b4w.require("app");
    var m_data = b4w.require("data");

    m_app.init({
        canvas_container_id: "body_id",
        callback: load_cb
    });

    function load_cb() {
        m_data.load("some_scene.json");
    }

    </script>
    </head>

    <body id="body_id"></body>

    </html>

В данном случае модуль ``app`` создаст элемент ``<canvas>`` внутри контейнера с
указанным идентификатором ``body_id``, осуществит инициализацию движка при
загрузке страницы и сообщит о её окончинии с помощью обработчика ``load_cb``.

Система модулей
===============

Несмотря на то, что движок предоставляет прикладному программисту API в объёме
десятков модулей, в процессе работы он занимает в глобальном пространстве имён
единственный объект ``b4w``. При необходимости обращения к модулю, последний
импортируется с помощью вызова функции ``b4w.require``. 

Допустима регистрация сторонних модулей, если их имена не пересекаются с
имеющимися. Регистрация происходит посредством вызова ``b4w.register``.
Проверка наличия модуля с некоторым именем может быть осуществлена с помощью
``b4w.module_check``.

Пример:

.. code-block:: javascript

    // check if module exists
    if (b4w.module_check("my_module"))
        throw "Failed to register module: my_module";

    // register my_module
    b4w.register("my_module", function(exports, require) {

        // import module "version"
        var m_version = require("version");

        // export print_build_date() from module "my_module"
        exports.print_build_date = function() {
            // exec function date() from module "version"
            console.log("Engine build date: " + m_version.date());
        }
    });

    // import module "my_module"
    var m_my_module = b4w.require("my_module");

    // exec function print_build_date() from module "my_module"
    m_my_module.print_build_date();

.. _repo_file_structure:

Файловая структура репозитория
==============================

**apps_dev**
    исходный код приложений

**closure-compiler**
    компилятор Google Closure, файлы исключений к нему, генераторы файлов исключений

**csrc**
    исходный код бинарной части экспортера движка и других утилит на языке C 

**dia**
    файлы диаграмм

    **graph.dia**
        схема рендеринга движка в формате Dia

    **modules_graph.dia**
        схема взаимосвязей модулей движка в формате Dia

    **node_materials_limits.svg**
        ограничения нодовых материалов 

    **shader_graph.dia**
        схема системы освещения движка в формате Dia


**doc_src**
    исходный код настоящего руководства пользователя на языке разметки reST
    
**external**

    **blender**
        рабочие файлы художников группы разработки движка

    **blender_scripts**
        экспортный и вспомогательные скрипты для Blender'а
    
    **deploy**

        **api_doc**
            документация API движка для разработчиков в формате HTML

        **apps** 
            3D-приложения, предназначенные для развертывания

        **assets** 
            загружаемые ресурсы: сцены, текстуры, звуковые файлы

            **assets.json**
                метаданные с информацией о сценах, загружаемых просмотрощиком
                viewer.js

        **doc**
            настоящее руководство пользователя в формате HTML

        **globals_detect**
            вспомогательный код для определения глобальных переменных

        **webglreport**
            страница для определения WebGL параметров

        **website**
            сайт разработчиков Lixer, предназначенный для развертывания

    **reexporter.py** и **Makefile** 
        Python-скрипт и файл сборки для автоматического экспорта всех сцен в *external/deploy/assets*

    **renamer.py**
        Python-скрипт для автоматического переименования свойств в .blend -
        файлах.

**glsl_utils**
    
    **compiler**
        компилятор GLSL шейдеров движка

        **out** 
            результат компиляции GLSL шейдеров движка

    **pegjs**
        грамматики парсер-генератора PEG.js для реализации препроцессора GLSL, а также скрипт для генерации модулей парсеров из этих грамматик

**index.html**  
    web-страница со ссылками на 3D-приложения

**js_bench**
    тестовые файлы, баг-репорты

    **node_test.js**
        пример NodeJS-скрипта, запускающего модуль движка

**license**
    файлы с текстами лицензионных соглашений

**Makefile**
    файл сборки для компиляции движка, приложений, документации, развертывания на удаленном сервере

**scripts**

    **assets_cleanup.py**
        скрипт для автоматической очистки файла assets.json

    **chrome_debug.sh**
        скрипт, запускающий браузер Chrome в режиме отладки

    **compile_b4w.sh**
        скрипт для вызова Google Closure Compiler с целью минификации и обфускации кода движка и приложений

    **converter.py**
        скрипт, осуществляющий: уменьшение разрешения текстур вдвое, компрессию текстур в формат dds, конвертацию звуковых файлов в форматы mp4 и ogg

    **custom_json_encoder.py**
        форк Python-модуля json, сортирует ключи по алфавиту в обратном порядке

    **gen_glmatrix.sh**
        скрипт для генерации математического модуля на основе исходных файлов из
        репозитория glMatrix 2

    **gpu_shader_analyzer_server.py**
        скрипт, запускающий локальный веб-сервер, который осуществляет подсчет сложности шейдеров с помощью утилиты AMD GPUShaderAnalyzer

    **graph.sh**
        генератор текущего графа сцены в формате svg

    **listing.sh**
        генератор листинга всех исходных кодов движка

    **make_dist.sh**
        построитель внешних дистрибутивов движка

    **memory.sh**
        скрипт для проверки обычной (RAM) и видео-памяти (VRAM)

    **netem.sh**
        эмулятор поведения медленных и ненадёжных каналов связи

    **plot.sh**
        построитель графиков отладочной информации

    **remove_alpha_channel.sh**
        скрипт для удаления альфа-канала изображения

    **report_unused_resources.py**
        скрипт для проверки и сообщения о неиспользуемых ресурсах (изображения и
        звуки, на которые ссылаются экспотируемые файлы)

    **screencast.sh**
        скрипт для записи видео с экрана

**shaders**
    GLSL шейдеры движка

**src**
    основной исходный код ядра движка

    **addons** 
        исходный код, являющийся внешним по отношению к ядру движка

    **ext**
        исходный код ядра движка, содержащий объявления API движка

    **third_party**
        код сторонних библиотек, использующихся в ядре движка

**ubuntu_setup**
    вспомогательный скрипт для обновления системы, файл справки, запускные файлы Chrome и Blender с настроенными путями и опциями

**uranium**
    исходный код и скрипты сборки физического движка Uranium

**website_src**
    исходный код и контент сайта разработчиков Lixer (устарел)


.. _dependencies:

Зависимости
===========

Для ведения эффективной разработки движка и приложений, необходим ряд сторонних
программ (зависимостей). Большинство этих зависимостей находится в составе
современных дистрибутивов GNU/Linux, таких как Ubuntu. В других Unix-подобных
системах (Apple OS X, FreeBSD) их установка из исходных кодов или иных
источников не представляет существенных проблем.

В таблице ниже перечислены все зависимости, в порядке убывания важности для
разработки.

+-------------------------------+-------------------------------+----------------------------+
| Название                      | Пакет в дистрибутиве Ubuntu   | Назначение                 |
|                               | 12.04                         |                            |
+===============================+===============================+============================+
| Bash                          | в составе по умолчанию        | интерпретатор скриптов     |
+-------------------------------+-------------------------------+----------------------------+
| Python 3                      | в составе по умолчанию        | интерпретатор скриптов     |
+-------------------------------+-------------------------------+----------------------------+
| NodeJS                        | nodejs                        | компиляция шейдеров        |
+-------------------------------+-------------------------------+----------------------------+
| Java                          | default-jre                   | компиляция и обфускация    |
|                               |                               | модулей движка             |
+-------------------------------+-------------------------------+----------------------------+
| LLVM, Clang                   | llvm, clang                   | сборка Uranium             |
+-------------------------------+-------------------------------+----------------------------+
| Emscripten                    | из исходных текстов           | сборка Uranium             |
+-------------------------------+-------------------------------+----------------------------+
| ImageMagick, GraphicsMagick   | imagemagick, graphicsmagick   | конвертация ресурсов       |
+-------------------------------+-------------------------------+----------------------------+
| NVIDIA Texture Tools          | libnvtt-bin                   | конвертация ресурсов       |
+-------------------------------+-------------------------------+----------------------------+
| FFmpeg (libav)                | ffmpeg                        | конвертация ресурсов       |
+-------------------------------+-------------------------------+----------------------------+
| Gnuplot                       | gnuplot                       | отладка                    |
+-------------------------------+-------------------------------+----------------------------+
| Graphviz                      | graphviz                      | отладка                    |
+-------------------------------+-------------------------------+----------------------------+
| xsel                          | xsel                          | отладка                    |
+-------------------------------+-------------------------------+----------------------------+
| Sphinx                        | sphinx-doc                    | сборка документации        |
|                               |                               | (HTML-версия)              |
+-------------------------------+-------------------------------+----------------------------+
| sphinx-intl                   | устанавливается с помощью PIP | сборка документации        |
|                               |                               | (перевод)                  |
+-------------------------------+-------------------------------+----------------------------+
| TeX Live                      | texlive, texlive-latex-extra  | сборка документации        |
|                               | texlive-lang-cyrillic         | (PDF-версия)               |
+-------------------------------+-------------------------------+----------------------------+
| JSDoc 3                       | из исходных текстов           | сборка документации        |
|                               |                               | (документация на API)      |
+-------------------------------+-------------------------------+----------------------------+
| PIP                           | python3-pip                   | разработка сайта           |
+-------------------------------+-------------------------------+----------------------------+
| Django, Pillow, unidecode     | устанавливается с помощью PIP | разработка сайта           |
+-------------------------------+-------------------------------+----------------------------+

.. _coding_style:

Стиль оформления кода
=====================

Применяется структурное программирование. Код организуется в модули. Подходы ООП не используются, классы не определяются, наследование не осуществляется и т.п. 

Используется `K&R стиль <http://en.wikipedia.org/wiki/1_true_brace_style#K.26R_style>`_, за исключением того, что открывающая скобка для составного оператора ставится на той же строке, например:

.. code-block:: javascript

    function foo_bar() {
        // ...
    }

    if (a > b) {
        // ...
    } 

Для выравнивания используются 4 пробела (табуляция запрещена).

Примеры
-------

В именах переменных и функций используется знак подчеркивания:

.. code-block:: javascript

    var foo_bar = 123;  // correct
    var fooBar = 123;   // wrong
    
Все глобальные переменные начинаются со знака подчеркивания:

.. code-block:: javascript

    var _foo_bar = null;

Константы пишутся прописными буквами и никогда не начинаются со знака подчеркивания:

.. code-block:: javascript

    var FOO_BAR = 100;

Для внешних API названия методов и свойств пишутся как строка во избежание обфускации:

.. code-block:: javascript

    exports["FOO_BAR"] = 123;

    exports["foo_bar"] = function() {
        
    }
 
Комментарии
-----------

Комментарии только на английском языке. Стиль комментирования - JSDoc.

.. _debugging:

Способ именования идентификаторов (функций, объектов, переменных)
=================================================================

*init_*
    создание абстрактного объекта.

*create_*
    создание конкретного объекта.

*update_*
    обновить состояние имеющегося объекта.

*attach_/detach_*
    добавить/удалить временное свойство к объекту.

*append_/remove_*
    добавить/удалить временное свойство к уже существующим подобного рода.

*insert_/pop_*
    добавить/удалить элемент массива (доступ по индексу места).

*apply_/clear_*
    операция с флагом, бинарной величиной или произвольным параметром.

*set_/get_*
    установить/получить значение свойства/переменной.

*_tmp*
    глобальная переменная-кеш в виде простого объекта (массив, вектор).

*_cache*
    глобальная переменная-кеш в виде сложного объекта.

Отладка
=======

Отладка движка производится с помощью методов модуля ``debug.js``.

Текущий формат рендеринг-графа может быть сохранён в формате DOT с помощью
вывова ``b4w.debug.scenegraph_to_dot()``. Для этого содержимое консоли после
вызова данного метода сохраняется в файл с расширением .gv. Чтобы получить граф
в графическом виде, необходим набор утилит `graphviz <http://www.graphviz.org/>`_.
Преобразование в формат SVG выполняется с помощью вызова:

.. code-block:: bash

    > dot -Tsvg graph.gv -o graph.svg

где ``graph.gv`` имя файла с сохранённым графом.

.. _shaders:

Шейдеры
=======

.. index:: обфускатор шейдеров

Обфускатор
----------

Используемые в движке шейдеры подвергаются обработке обфускатором. 
Для запуска обфускации требуется выполнить одну из команд в корне репозитория:

* ``make compile_shaders`` - проверка, обфускация и экспорт скомпилированных шейдеров
* ``make verify_shaders`` - только проверка и обфускация

Обфускатор служит для сокращения объема, оптимизации и затруднения понимания 
glsl-кода. На данный момент в нем реализованы следующие процедуры:

* удаление лишних пробелов, переводов строк и повторяющихся символов ";"
* замена пользовательских идентификаторов более короткими односимвольными, двухсимвольными и т.д. именами
* вывод сообщений о неиспользуемых переменных и функциях (dead code)
* проверка синтаксиса шейдеров
* поддержка import/export-механизма и проверка шейдеров на соответствие ему

В процессе обфускации сначала осуществляется парсинг или синтаксический анализ 
текста шейдера. Соответствующий парсер строится на основе грамматики с помощью генератора `PEG.js <http://pegjs.majda.cz/>`_. Далее по данным парсинга осуществляются оптимизационные процедуры и валидация шейдеров; затем шейдеры могут быть экспортированы в виде абстрактного синтаксического дерева (АСТ) для непосредственной загрузки движком.

Расположение основных файлов в репозитории:

* исходная грамматика - glsl_utils/pegjs/glsl_parser.pegjs
* скрипт генерации парсера - glsl_utils/pegjs/gen_nodejs.sh
* парсер - glsl_utils/compiler/glsl_parser.js

.. index:: обфускатор шейдеров; директивы import/export

Директивы import/export
-----------------------

В целях упорядочивания, структурирования и повышения удобочитаемости кода шейдеров в include-файлах используются директивы import и export.
Они указываются в начале файла и должны выглядеть примерно следующим образом:

.. code-block:: glsl

    #import u_frame_factor u_quatsb u_quatsa u_transb u_transa a_influence 
    #import qrot

    #export skin

Директива ``#import`` определяет набор идентификаторов, которые являются внешними для файла (т.е. их обявления содержатся вне этого include-файла), но доступными для использования в нем. Логичным ограничением здесь является требование обязательного объявления таких идентификаторов где-либо выше места поключения include-файла.
Директива ``#export`` определяет набор идентификаторов, доступных для использования вне данного файла. Такие идентификаторы должны быть обязательно объявлены в этом файле.

Таким образом, шейдер, использующий include-файл, обязан до места подключения содержать объявления, необходимые для импорта, а после него может использовать экспортируемые идентификаторы.

Идентификаторами могут быть как имена переменных, так и функций. По умолчанию при отсутствии директив import/export считается, что include-файл не использует внешние объявления и не предоставляет пользование внутренними.

.. index:: обфускатор шейдеров; ограничения

Рекомендации и ограничения по использованию обфускатора
-------------------------------------------------------

В связи с наличием препроцессинга, необходимостью совместной обработки нескольких шейдеров и include-файлов, а также особенностями реализации обфускатора гарантировать работоспособность полученного на выходе кода можно только при соблюдении ряда правил или ограничений на текст исходных шейдеров:

1. Обязательное использование специальной директивы ``#var`` для описания констант, определяемых движком в момент запуска. Например:

.. code-block:: glsl

    #var AU_QUALIFIER uniform
    AU_QUALIFIER float a;

Синтаксис здесь схож с директивой #define. Смысл директивы #var в том, чтобы определяемое ею значение позволило распарсить исходный шейдер. Что это будет конкретно (например, 'unform' или 'attribute' в пример выше), не важно, т.к. на этом этапе оно все равно неизвестно. Однако, желательно указывать более-менее подходящее описание, а не что-то совершенно произвольное.

.. note::

    Для констант, используемых не в коде шейдера, а в выражениях препроцессинга, директива ``#var`` не обязательна.

2. Использование при необходимости директив import/export.
3. Не следует перегружать встроенные функции, только пользовательские.
4. Не следует объявлять переменные с именем одной из встроенных функций, либо main даже, если это не приводит к ошибке.
5. Нельзя использовать директивы #var и #define для замены отдельных символов в таких операторах, как: "++", "--", "\*=", "/=", "+=", "-=", "==", "<=", ">=", "!=", "&&", "||", "^^".

Например:

.. code-block:: glsl

    #var EQUAL =
    ...
    a *EQUAL b;
    ...

6. Использование директивы #include, не должно приводить к неоднозначности при обфускации содержимого include-файла. Это может произойти в том случае, когда один и тот же файл включается в несколько разных шейдеров, и в каком-то из них могут повлиять определенные выше директивы, вроде #var или #define. Также не стоит использовать в include-файле необъявленные функции и переменные.

7. Использование вложенных include'ов или множественного включения одного и того же include'a в один и тот же шейдер не поддерживается.
8. К неработоспособности шейдера приведет (может привести) нетривиальное использование препроцессинга, например, создающее невалидный glsl-код:

.. code-block:: glsl

    #if TYPE
    void function1() {
    #else
    void function1(int i) {
    #endif
        ...
    }

.. index:: WebGL; расширения

Поддержка WebGL-расширений
--------------------------

Работа обфускатора может зависеть от используемых WebGL-расширений, если они каким-либо образом влияют на шейдерный язык.
На данный момент поддерживаются следующие расширения:

    * OES_standard_derivatives

.. index:: обфускатор шейдеров; ошибки

Ошибки обфускатора
------------------

В случае ошибки обфускатор выведет соответствующее сообщение в консоли.

Перечень возможных ошибок:

+-------------------------------------+-------------------------------------------+
| Сообщение об ошибке                 | Причина                                   |
+=====================================+===========================================+
| Error! Ambiguous obfuscation in     | Ошибка! Неоднозначная обфускация          |
| include file 'FILE_NAME'.           | include-файла FILE_NAME.                  |
+-------------------------------------+-------------------------------------------+
| Error! Bad preprocessing collision  | Ошибка в файле FILE_NAME. Невозможность   |
| while obfuscation identifier:       | обфускации переменной с именем NAME из-за |
| \'NAME'. Varying/uniform or         | переопределения при препроцессинге.       |
| varying/attribute qualifiers        | Переопределение одной и той же переменной |
| combination. File: 'FILE_NAME'.     | с разными квалификаторами. Недопустимые   |
|                                     | комбинации: varying/uniform,              |
|                                     | varying/attribute.                        |
+-------------------------------------+-------------------------------------------+
| Error! Extension NAME is            | Ошибка! WebGL-расширение с именем NAME,   |
| unsupported in obfuscator. File:    | использованное в файле FILE_NAME, не      |
| 'FILE_NAME'.                        | поддерживается обфускатором.              |
+-------------------------------------+-------------------------------------------+
| Error! Include 'FILE_NAME' not      | Ошибка! При подключении не найден         |
| found.                              | include-файл FILE_NAME.                   |
+-------------------------------------+-------------------------------------------+
| Error! Undeclared TYPE: 'NAME'.     | Ошибка в файле FILE_NAME. Необъявленный   |
| File: 'FILE_NAME'.                  | идентификатор типа TYPE (переменная,      |
|                                     | функция, структура, ...) с именем NAME.   |
+-------------------------------------+-------------------------------------------+
| Error! Undeclared TYPE: 'NAME'.     | Ошибка! Необъявленный идентификатор типа  |
| Importing data missed. File:        | TYPE (переменная, функция, структура, ... |
| 'FILE_NAME'.                        | ) с именем NAME. Отсутствует объявление   |
|                                     | идентификатора, требуемого в              |
|                                     | include-файле FILE_NAME согласно          |
|                                     | директиве ``#import``.                    |
+-------------------------------------+-------------------------------------------+
| Error! Undeclared TYPE: 'NAME'.     | Ошибка в файле FILE_NAME. Необъявленный   |
| Possibly exporting needed in        | идентификатор типа TYPE (переменная,      |
| include file 'INCLUDE_NAME'. File:  | функция, структура, ...) с именем NAME.   |
| 'FILE_NAME'.                        | Возможно требуется разрешить его экспорт  |
|                                     | в include-файле INCLUDE_NAME.             |
+-------------------------------------+-------------------------------------------+
| Error! Undeclared TYPE: 'NAME'.     | Ошибка! Необъявленный идентификатор типа  |
| Possibly importing needed. File:    | TYPE (переменная, функция, структура, ... |
| 'FILE_NAME'.                        | ) с именем NAME. Возможно требуется       |
|                                     | указать его как импортируемый в           |
|                                     | include-файле FILE_NAME.                  |
+-------------------------------------+-------------------------------------------+
| Error! Unused export token 'NAME'   | Ошибка! В include-файле FILE_NAME         |
| in include file 'FILE_NAME'.        | разрешен для экспорта необъявленный       |
|                                     | идентификатор с именем NAME.              |
+-------------------------------------+-------------------------------------------+

+-------------------------------------+-------------------------------------------+
| Error! Using reserved word in TYPE  | Ошибка в файле FILE_NAME. Использование   |
| 'NAME'. File: 'FILE_NAME'.          | зарезервированного слова при объявлении   |
|                                     | идентификатора типа TYPE (переменная,     |
|                                     | функция, структура, ...) с именем NAME.   |
+-------------------------------------+-------------------------------------------+
| Error! 'all' extension cannot have  | Ошибка! Директива ``#extension``,         |
| BEHAVIOR_TYPE behavior. File:       | указанная для всех (``all``)              |
| 'FILE_NAME'.                        | WebGL-расширений в файле FILE_NAME, не    |
|                                     | поддерживает поведение BEHAVIOR_TYPE.     |
+-------------------------------------+-------------------------------------------+
| Syntax Error. ERROR_MESSAGE. File:  | Ошибка синтаксиса в строке LINE_NUMBER,   |
| FILE_NAME, line: LINE_NUMBER,       | столбце COL_NUMBER при парсинге шейдера   |
| column: COL_NUMBER.                 | FILE_NAME. Исходное описание ошибки       |
|                                     | приведено в ERROR_MESSAGE. В сообщении    |
|                                     | прилагается листинг кода в окрестности    |
|                                     | соответствующей строки (следует           |
|                                     | учитывать особенность pegjs-парсеров,     |
|                                     | указывающих чуть далее места, вызвавшего  |
|                                     | ошибку).                                  |
+-------------------------------------+-------------------------------------------+
| Warning! Function 'NAME' is         | В файле FILE_NAME объявлена функция NAME, |
| declared in [include ]file          | которая нигде не используется.            |
| FILE_NAME, but never used.          |                                           |
+-------------------------------------+-------------------------------------------+
| Warning! Include file 'FILE_NAME'   | Include-файл FILE_NAME не используется ни |
| not used in any shader, would be    | в одном из шейдеров, поэтому будет        |
| omitted!                            | исключен из закомпиленной версии.         |
+-------------------------------------+-------------------------------------------+
| Warning! Unused import token 'NAME' | Идентификатор с именем NAME импортируется |
| in include file 'FILE_NAME'.        | в include-файле FILE_NAME, но нигде не    |
|                                     | используется.                             |
+-------------------------------------+-------------------------------------------+
| Warning! Variable 'NAME' is         | В файле FILE_NAME объявлена переменная    |
| declared in [include ]file          | NAME, которая нигде не используется.      |
| FILE_NAME, but never used.          |                                           |
+-------------------------------------+-------------------------------------------+

.. index:: кватернион

Кватернионы
===========

Кватернионы представляют собой четырёхмерные векторы, используемые для осуществления поворотов. Использование кватернионов обладает рядом преимуществ перед другими способами представления поворотов:

    - Не имеет неоднозначности и зависимости от порядка применения поворотов, которые имеют место в случае использования углов эйлера.
    - Более эффективное использование памяти (от 2-х до 4-х раз меньше в зависимости от типа используемой матрицы).
    - Высокая эффективность вычисления серии поворотов, чем при использовании матриц.
    - Нейтрализация ошибок умножения, возникающих вследствие неточности чисел с плавающей запятой.
    - Удобный метод интерполяции.
    
Кватернионы имеют ряд недостатков:
    - Поворот вектора с помощью кватерниона более сложная в вычислительном плане операция чем поворот с использованием матрицы.
    - Использование кватернионов для представления отличных от поворота преобразований (перспективная или ортогональная проекция) затруднено.

Для удобства работы с кватернионами в движке имеется ряд функций:

*quat.multiply*
    Умножение кватернионов. Умножение кватерниона А на кватернион Б слева A*Б является поворотом на A. То есть у объекта уже имеется некий поворот Б, который мы дополняем новым поворотом на A.
    
*quat.setAxisAngle*
    Кватернион представляет собой иную форму записи поворота относительно произвольной оси (вектора) на произвольный угол. Положительное направление поворота отсчитывается против часовой стрелки, если смотреть с конца вектора. Например вызов `quat.setAxisAngle([1,0,0], Math.PI/2, quat)` создаст кватернион, который может быть использован для осуществления поворота относительно оси X на 90 градусов (против часовой стрелки, если смотреть с конца оси X).
    
*quat.slerp*
    Сферическая интерполяция кватернионов. Используется для осуществления плавного разворота объектов и анимации.
    
Пример:

Требуется повернуть объект `CAR` на 90 градусов в вертикальной плоскости, для того, чтобы осуществить поворот налево. Имеется модель в программе Blender.

    * Смотрим куда направлен `СAR` в программе Blender. Чаще всего это ось -Y. В результате преобразования координат: X Y Z -> X -Z Y, вертикальная ось Z займёт положение оси Y в движке. Следовательно, для осуществления поворота на 90 градусов налево необходимо осуществить поворот относительно Y против часовой стрелки, что соответствует положительному углу вращения. Код для реализации поворота будет иметь вид:
    
.. code-block:: javascript
    
    // compose quaternion
    var quat_90 = b4w.quat.setAxisAngle([0,1,0], Math.PI/2, b4w.quat.create());
    // get old rotation
    var quat_old = b4w.transform.get_rotation(CAR);
    // compose new rotation: quat90*quat_old
    var quat_new = b4w.quat.multiply(quat_90, quat_old, b4w.quat.create());
    // set new rotation
    b4w.transform.set_rotation_v(CAR, quat_new);

Оптимизированный вариант:

.. code-block:: javascript
    
    // caches (globals)
    var axis_y = new Float32Array([0,1,0])
    var quat_tmp = new Float32Array(4);
    var quat_tmp2 = new Float32Array(4);
    ...
    // code
    b4w.quat.setAxisAngle(axis_y, Math.PI/2, quat_tmp);
    b4w.transform.get_rotation(CAR, quat_tmp2);
    b4w.quat.multiply(quat_tmp, quat_tmp2, quat_tmp);
    b4w.transform.set_rotation_v(CAR, quat_tmp);
    
