.. _developers:

************************
Разработчикам приложений
************************

Простейшее приложение (Hello world!)
====================================

Простейшее приложение на движке может иметь вид:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_version = b4w.require("version");
        document.body.innerHTML = "Hello, Blend4Web " + m_version.version() + "!";
    }
    </script>
    </head>

    <body onload="hello()"></body>

    </html>

Базовый код движка подключается с помощью тега ``<script src="...">``. Далее,
приложение ожидает окончания загрузки страницы и выводит сообщение с текущей
версией в окне браузера. В данном примере используется единственный модуль
``version``, в котором находится одноимённая функция ``version()``. Подробную
информацию о предназначении модулей и функций движка можно найти в `документации
по API <http://www.blend4web.com/api_doc/index.html>`_.

Файлы со скомпилированным кодом движка находятся в директории SDK
``external/deploy/apps/common``. Файл ``b4w.min.js`` содержит в себе базовую
версию, в случае необходимости использования аддонов, вместо него используется
``b4w.full.min.js``.

Загрузка сцены в приложение
===========================

Для того, чтобы загрузить трёхмерную сцену, требуется выполнить следующую
последовательность действий:

#. Разместить на странице элемент ``<canvas>``, на котором будет производиться
   рендеринг.

#. После загрузки страницы, для инициализации контекста WebGL, вызвать функцию
   ``m_main.init()`` с идентификатором созданного элемента.

#. Вызвать функцию ``m_data.load()`` для загрузки трёхмерной сцены.

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.min.js"></script>
    <script>
    function hello() {
        var m_main = b4w.require("main");
        var m_data = b4w.require("data");

        var canvas_elem = document.getElementById("canvas_id");
        m_main.init(canvas_elem);
        m_data.load("some_scene.json");
    }
    </script>
    </head>

    <body onload="hello()"><canvas id="canvas_id"></canvas></body>

    </html>

Следует отметить, что реальное приложение должно включать в себя проверку
ошибок, настройку движка перед инициализацией, а также базовую систему
взаимодействия с пользователем.


Быстрое создание приложений
===========================

Поскольку создание приложения с нуля может быть достаточно сложной операцей,
особенно для начинающих пользователей, в движке существует специальное
дополнение ``app``:

.. code-block:: html

    <!DOCTYPE html>
    <html>
    <head>
    <script src="b4w.full.min.js"></script>
    <script>

    var m_app = b4w.require("app");
    var m_data = b4w.require("data");

    m_app.init({
        canvas_container_id: "body_id",
        callback: load_cb
    });

    function load_cb() {
        m_data.load("some_scene.json");
    }

    </script>
    </head>

    <body id="body_id"></body>

    </html>

В данном случае модуль ``app`` создаст элемент ``<canvas>`` внутри контейнера с
указанным идентификатором ``body_id``, осуществит инициализацию движка при
загрузке страницы и сообщит о её окончании с помощью обработчика ``load_cb``.


Система модулей
===============

Несмотря на то, что движок предоставляет прикладному программисту API в объёме
десятков модулей, в процессе работы он занимает в глобальном пространстве имён
единственный объект ``b4w``. При необходимости обращения к модулю, последний
импортируется с помощью вызова функции ``b4w.require``. 

Допустима регистрация сторонних модулей, если их имена не пересекаются с
имеющимися. Регистрация происходит посредством вызова ``b4w.register``.
Проверка наличия модуля с некоторым именем может быть осуществлена с помощью
``b4w.module_check``.

Пример:

.. code-block:: javascript

    // check if module exists
    if (b4w.module_check("my_module"))
        throw "Failed to register module: my_module";

    // register my_module
    b4w.register("my_module", function(exports, require) {

        // import module "version"
        var m_version = require("version");

        // export print_build_date() from module "my_module"
        exports.print_build_date = function() {
            // exec function date() from module "version"
            console.log("Engine build date: " + m_version.date());
        }
    });

    // import module "my_module"
    var m_my_module = b4w.require("my_module");

    // exec function print_build_date() from module "my_module"
    m_my_module.print_build_date();




Управление перемещением объектов
================================

.. note::

    Необходимо обеспечить, чтобы объект, над которым выполняется преобразование, был :ref:`динамическим <static_dynamic_objects>`.

Для управления перемещением объектов в движке предусмотрены следующие базовые функции модуля `transform`:

*get_translation*
    Получить координаты центра объекта. Вариант с одним параметром возвращает
    новый вектор (неоптимизированный вариант), вариант с двумя требует
    отдельного вектора для записи результата.

*get_rotation*
    Получить кватернион поворота объекта. По аналогии с `get_translation` имеется два варианта вызова функции.
    
*get_scale*
    Получить значение коэффициента увеличения объекта.

*set_translation, set_translation_v*
    Переместить центр объекта в указанное место. Первая функция принимает в качестве параметров отдельные координаты, вторая - трёхмерный вектор (Array или Float32Array).
    
*set_rotation, set_rotation_v*
    Установить кватернион поворота объекта. Первая функция принимает в качестве параметров отдельные координаты, вторая - четырёхмерный вектор (Array или Float32Array).

*set_scale*
    Установить коэффициент увеличения объекта. Единица соответствует исходному состоянию. Значение меньше единицы - уменьшение. Значение больше единицы - увеличение. Не все объекты могут быть увеличены. В частности, увеличение невозможно для физических объектов.

*set_rotation_euler, set_rotation_euler_v*
    Установить поворот объекта с помощью углов Эйлера. Используется
    **внутренняя** (intrinsic) система поворота YZX (то есть углы следуют в
    последовательности YZX, сама система отсчёта при этом вращается и занимает
    каждый раз новое положение).



.. index:: кватернион

Кватернионы
===========

Кватернионы представляют собой четырёхмерные векторы, используемые для осуществления поворотов. Использование кватернионов обладает рядом преимуществ перед другими способами представления поворотов:

    - Не имеет неоднозначности и зависимости от порядка применения поворотов, которые имеют место в случае использования углов Эйлера.
    - Более эффективное использование памяти (от 2-х до 4-х раз меньше в зависимости от типа используемой матрицы).
    - Высокая эффективность вычисления серии поворотов, чем при использовании матриц.
    - Нейтрализация ошибок умножения, возникающих вследствие неточности чисел с плавающей запятой.
    - Удобный метод интерполяции.
    
Кватернионы имеют ряд недостатков:
    - Поворот вектора с помощью кватерниона более сложная в вычислительном плане операция чем поворот с использованием матрицы.
    - Использование кватернионов для представления отличных от поворота преобразований (перспективная или ортогональная проекция) затруднено.

Для удобства работы с кватернионами в движке имеется ряд функций:

*quat.multiply*
    Умножение кватернионов. Умножение кватерниона А на кватернион Б слева A*Б является поворотом на A. То есть у объекта уже имеется некий поворот Б, который мы дополняем новым поворотом на A.
    
*quat.setAxisAngle*
    Кватернион представляет собой иную форму записи поворота относительно произвольной оси (вектора) на произвольный угол. Положительное направление поворота отсчитывается против часовой стрелки, если смотреть с конца вектора. Например вызов :code:`quat.setAxisAngle([1,0,0], Math.PI/3, quat)` сформирует кватернион, который может быть использован для осуществления поворота относительно оси X на 60 градусов (против часовой стрелки, если смотреть с конца оси X).
    
*quat.slerp*
    Сферическая интерполяция кватернионов. Используется для осуществления плавного разворота объектов и анимации.

*util.euler_to_quat, util.quat_to_euler*.
    Преобразование из углов Эйлера и наоборот.
    

Пример работы с кватернионами
-----------------------------

Требуется повернуть объект на 60 градусов в горизонтальной плоскости вправо. В программе Blender имеется соответствующая модель с названием "Cessna". 

.. image:: src_images/developers/aircraft.jpg
   :align: center
   :width: 100%

|

Сохраним ссылку на объект в движке в переменной **aircraft**:
    
.. code-block:: javascript

    var aircraft = m_scenes.get_object_by_name("Cessna");


Осуществим поворот:

    * Расположение координатных осей в Blender'е и в движке различается, и при экспорте произойдет преобразование: [X Y Z] (Blender) -> [X -Z Y] (движок). Поэтому поворот нужно осуществлять относительно оси Y, а не Z. 
    * Повороту вправо соответствует поворот по часовой стрелке, т.е. в отрицательном направлении. 
    * 60 градусов = :math:`\pi/3` радиан. 
    
В итоге получаем:
    
.. code-block:: javascript
    
    // compose quaternion
    var quat_60_Y_neg = m_quat.setAxisAngle([0, 1, 0], -Math.PI/3, m_quat.create());

    // get old rotation
    var quat_old = m_transform.get_rotation(aircraft);

    // left multiply: quat60_Y_neg * quat_old
    var quat_new = m_quat.multiply(quat_60_Y_neg, quat_old, m_quat.create());

    // set new rotation
    m_transform.set_rotation_v(aircraft, quat_new);


Оптимизированный вариант, не приводящий к созданию новых объектов:

.. code-block:: javascript
    
    // cache arrays as global vars
    var AXIS_Y = new Float32Array([0, 1, 0])
    var quat_tmp = new Float32Array(4);
    var quat_tmp2 = new Float32Array(4);
    ...
    // rotate
    m_quat.setAxisAngle(AXIS_Y, -Math.PI/3, quat_tmp);
    m_transform.get_rotation(aircraft, quat_tmp2);
    m_quat.multiply(quat_tmp, quat_tmp2, quat_tmp);
    m_transform.set_rotation_v(aircraft, quat_tmp);
    


.. _event_model:

Событийная модель
=================

Событийная модель предоставляет унифицированный интерфейс для описания
изменения состояний 3D сцены, упрощая обработку событий физики и действий 
пользователя.

.. index:: сенсор, sensor

Сенсоры
-------

Основным блоком событийной модели является сенсор (sensor). Сенсор является
программной сущностью, и может быть только активным (1, единица) или неактивным (0, ноль). 
Некоторые сенсоры несут полезную нагрузку (payload). Например, сенсор трассировки лучей (Ray Sensor) 
предоставляет относительную длину луча пересечения.

.. index:: сенсор; множество, sensor; manifold

Управление сенсорами не доступно пользователю в виде открытого API. Вместо этого
каждый сенсор должен присутствовать в одном или нескольких множествах (sensor
manifold). Множество является логическим контейнером, ассоциированным с объектом на сцене.
Оно генерирует ответ на определенный набор событий сенсоров в виде вызова
функции-обработчика. Для определения множества необходимо иметь
следующую информацию (см. также описание функции ``controls.create_sensor_manifold()`` в документации по API):

* Объект-носитель множества (например, бросаемый объект).
* Уникальный идентификатор множества (например, "IMPACT").
* Тип вызова функции-обработчика (варианты: ``CT_CONTINUOUS`` - непрерывный, 
    ``CT_LEVEL`` - уровень, ``CT_SHOT`` - одномоментный, ``CT_TRIGGER`` - переключающий).
* Массив сенсоров.
* Логическая функция, определяющая при какой комбинации состояний сенсоров вызывается функция-обработчик.
* Функция-обработчик.
* Необязательный параметр, который может быть передан в функцию-обработчик.


Пример
------

Поставлена задача озвучить удар бросаемого камня так, чтобы
при ударе о различные среды (например, земля и стена) выводился характерный звук. 
На сцене в Blender'е имеются ограничивающие меши с физическими материалами, их идентификаторы "TERRAIN" и "WALL". 
На сцене также присутствует бросаемый физический объект с названием "Stone".


Определим по одному сенсору соударения (Collision Sensor) для каждой среды, 
по типу издаваемого звука. 


.. code-block:: javascript

    // import the modules
    var m_scenes = b4w.require("scenes");
    var m_controls = b4w.require("controls");

    // get the object being thrown
    var stone = m_scenes.get_object_by_name("Stone");

    // create the sensors
    var sensor_impact_terrain = m_controls.create_collision_sensor(stone, "TERRAIN");
    var sensor_impact_wall    = m_controls.create_collision_sensor(stone, "WALL");



Добавим сенсоры в массив. В качестве логической функции используем логическое ИЛИ. В обработчике напишем код для воспроизведения звука. Создадим множество сенсоров с идентификатором "IMPACT" и типом CT_SHOT (одномоментный). 


.. code-block:: javascript

    // array of the sensors
    var impact_sens_array = [sensor_impact_terrain, sensor_impact_wall];

    // manifold logic function
    var impact_sens_logic = function(s) {return (s[0] || s[1])};

    // callback
    var impact_cb = function(obj, manifold_id, pulse) {

        // NOTE: it's possible to play both sounds simultaneously 
        
        if (m_controls.get_sensor_value(obj, manifold_id, 0) == 1) {
            // ...
            console.log("play the terrain impact sound");
        }
                
        if (m_controls.get_sensor_value(obj, manifold_id, 1) == 1) {
            // ...
            console.log("play the wall impact sound");
        }
    }

    // create the manifold
    m_controls.create_sensor_manifold(stone, "IMPACT", m_ctl.CT_SHOT,
        impact_sens_array, impact_sens_logic, impact_cb);


При столкновении объекта "Stone" с любым из физических материалов 
"TERRAIN" или "WALL" происходит вызов функции-обработчика. 
Внутри этой функции получим значения обоих сенсоров по их индексу в массиве сенсоров (0 - "TERRAIN", 1 - "WALL").
Значение сенсора = 1 (активный) означает, что произошло столкновение с соответствующим физическим материалом. 
В результате воспроизводится соответствующий звук (код не показан).


.. _quality_settings:

Профили качества изображения
============================

Для поддержки различных по функциональности платформ в движке реализовано несколько профилей качества изображения:

    * *низкое качество* (P_LOW) - отключен ряд функций (тени, динамическое отражение, постпроцессинг), размер текстур для сборочной версии уменьшен вдвое, антиалиасинг отключен
    * *высокое качество* (P_HIGH) - используются все запрошенные сценой функции, метод антиалиасинга FXAA
    * *максимальное качество* (P_ULTRA) - вдвое увеличено разрешение рендеринга, увеличено разрешение карт теней, метод антиалиасинга SMAA


.. image:: src_images/developers/quality.jpg
   :align: center
   :width: 100%

|

Переключение профилей качества осуществляется программно, до инициализации контекста WebGL. Профиль по умолчанию P_HIGH.

.. code-block:: javascript

    var m_cfg = b4w.require("config");
    var m_main = b4w.require("main");

    m_cfg.set("quality", m_cfg.P_LOW);
    m_main.init(...);


Разработчики приложений могут также установить параметр **quality** при инициализации движка с использованием дополнения ``app.js``:

.. code-block:: javascript

    var m_cfg = b4w.require("config");
    var m_app = b4w.require("app");

    m_app.init({
        canvas_container_id: "body_id",
        quality: m_cfg.P_HIGH
    });
    
    

.. _repo_file_structure:

Файловая структура SDK
======================

**apps_dev**
    исходный код приложений (не все приложения доступны в бесплатной версии)

**closure-compiler**
    компилятор Google Closure, файлы исключений к нему, генераторы файлов исключений

**csrc**
    исходный код бинарной части экспортера движка и других утилит на языке C 

**doc_src**
    исходный код настоящего руководства пользователя на языке разметки reST
    
**external**
    **blender**
        исходные файлы сцен в формате Blender (не все сцены доступны в
        бесплатной версии)

    **blender_scripts**
        экспортер и вспомогательные скрипты для Blender'а
    
    **deploy**
        **api_doc**
            документация API движка для разработчиков в формате HTML
            (собирается автоматически, на основе исходного кода движка)

        **apps** 
            3D-приложения, предназначенные для развертывания, директория
            дублирует *apps_dev*

            **common**
                Файлы скомпилированного движка. Используются всеми
                приложениями из состава SDK (отсюда и название).

        **assets** 
            загружаемые ресурсы: сцены, текстуры, звуковые файлы (не все ресурсы
            доступны в бесплатной версии)

            **assets.json**
                метаданные с информацией о сценах, загружаемых просмотрщиком сцен
                Viewer

        **doc**
            настоящее руководство пользователя в формате HTML, собирается
            автоматически из *doc_src*

        **globals_detect**
            вспомогательный код для определения глобальных переменных

        **tutorials**
            исходные файлы обучающих примеров

    **reexporter.py** и **Makefile** 
        Python-скрипт и файл сборки для автоматического экспорта всех сцен в
        *external/deploy/assets*

**glsl_utils**
    **compiler**
        компилятор GLSL-шейдеров движка

        **out** 
            содержит результат компиляции GLSL-шейдеров движка

    **pegjs**
        грамматики парсер-генератора PEG.js для реализации препроцессора GLSL,
        а также скрипт для генерации модулей парсеров из этих грамматик

**index.html**  
    web-страница со ссылками на 3D-приложения (недоступен в бесплатной версии)

**license**
    файлы с текстами лицензионных соглашений

**Makefile**
    файл сборки для компиляции движка, приложений, документации, развертывания
    на удаленном сервере (недоступен в бесплатной версии)

**README.rst**
    файл README

**scripts**
    дополнительные скрипты

    **chrome_debug.sh**
        скрипт, запускающий браузер Chrome в режиме отладки

    **compile_b4w.py**
        скрипт для вызова Google Closure compiler с целью минификации и обфускации кода движка и приложений

    **converter.py**
        скрипт, осуществляющий: уменьшение разрешения текстур вдвое, компрессию текстур в формат DDS, конвертацию звуковых файлов в форматы mp4 и ogg

    **custom_json_encoder.py**
        форк Python-модуля json, сортирует ключи по алфавиту в обратном порядке

    **gen_glmatrix.sh**
        скрипт для генерации математического модуля на основе исходных файлов из
        репозитория glMatrix 2

    **gpu_shader_analyzer_server.py**
        скрипт, запускающий локальный веб-сервер, который осуществляет подсчет
        сложности шейдеров

    **graph.sh**
        генератор текущего графа сцены в формате svg, используется для отладки
        рендеринга

    **memory.sh**
        скрипт для проверки обычной (RAM) и видео-памяти (VRAM)

    **plot.sh**
        построитель графиков отладочной информации

    **remove_alpha_channel.sh**
        скрипт для удаления альфа-канала изображения

    **report_unused_resources.py**
        скрипт для проверки и сообщения о неиспользуемых ресурсах (изображения и
        звуки, на которые ссылаются экспотируемые файлы)

    **screencast.sh**
        скрипт для записи видео с экрана

**shaders**
    GLSL-шейдеры движка

**src**
    основной исходный код ядра движка

    **addons** 
        исходный код дополнений (не входят в ядро движка, подключаются отдельно)

    **ext**
        исходный код внешних объявлений (формирует API движка)

    **third_party**
        код сторонних библиотек

**uranium**
    исходный код и скрипты сборки физического движка Uranium (форк Bullet)

**VERSION**
    содержит текущую версию движка
